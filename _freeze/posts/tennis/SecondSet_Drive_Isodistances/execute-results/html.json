{
  "hash": "b08fbb2305159845cc197b5b00acfb98",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: 'Second Set: Drive Isodistances'\ndate: '2024-09-02'\ncategories: ['R', 'Geospatial','New Zealand']\ndescription: 'In this post, I look at how you can use road network data to get drive time radii around Tennis courts in Auckland, New Zealand.'\nauthor: 'Steven Turnbull'\nexecute: \n  message: false\n  warning: false\neditor_options: \n  chunk_output_type: console\n---\n\n\n\n# Understanding Catchment Areas\n\nIn a [previous post](https://sturbull.github.io./posts/tennis/FirstSet_Webscraping_and_GeoCoding.html) I outlined how we can take a set of addresses scraped from Tennis NZs [website](https://tennis.kiwi/play/play-tennis/) and geocode them to get latitude and longitude coordinates. This gave us the locations of all tennis clubs in Auckland, New Zealand. Now we have the data in a good format for mapping, we can carry out various forms of additional analysis.\n\nA couple of super powerful tools to have at our disposal are the isodistance and [isochrone](https://wiki.openstreetmap.org/wiki/Isochrone)! Simply, an isodistance is a radius around a point on a map that indicates a distance away from that point. An isochrone is the same, but using travel *time* rather than distance. This will be impacted by various factors, such as proximity to motoways, rurality, geographic obstacles and so on.\n\nThere are various services that you can use to get this information, but I will show you how you can carry out this work yourself. Using R, we can save time by progamatically going through all of our data automatically, and we can save money (no API calls to services needed). We're going to draw upon data on the New Zealand road network to carry out our work. Here's a map I made earlier that visualises this network, which is based on the data provided by Beere, P., (2016).\n\n![New Zealand Road Network](MappingNZ_2023_11_06.png){fig-align=\"center\" height=\"50%\" width=\"50%\"}\n\nAs a first step, we're going to load up the tennis club data.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(here)\nlibrary(dplyr)\nlibrary(reactable)\ndf <- read.csv(here(\"inputs\",\"tennis\",\"tennis_coords.csv\"))\n\n#We know the geocoding failed on some addresses, so we'll exclude those\ndf_clean <- df |>\n  filter(!is.na(latitude) | !is.na(longitude)) \n\ndf_clean |> \n  head() |>\n  reactable()\n```\n\n::: {.cell-output-display}\n\n```{=html}\n<div class=\"reactable html-widget html-fill-item\" id=\"htmlwidget-4587d2985938ffbd00b6\" style=\"width:auto;height:auto;\"></div>\n<script type=\"application/json\" data-for=\"htmlwidget-4587d2985938ffbd00b6\">{\"x\":{\"tag\":{\"name\":\"Reactable\",\"attribs\":{\"data\":{\"name\":[\"Next Generation Auckland Domain\",\"Pompallier Lawn Tennis Club\",\"Ngatira Tennis Club\",\"Gladstone Tennis Club\",\"Herne Bay Ponsonby Rackets Club\",\"Mt Eden Tennis Club\"],\"storepoint_address\":[\"1 Tennis Lane Parnell, Auckland,  1010, New Zealand\",\"11 Green Street Ponsonby,  1011, New Zealand\",\"24 Clive Road Mount Eden,  1024, New Zealand\",\"120 Gladstone Road Parnell, Auckland,  1052, New Zealand\",\"10 West End Road Herne Bay,  1022, New Zealand\",\"22 Poronui Street Mount Eden,  1024, New Zealand\"],\"latitude\":[-36.8543941,-36.8461653,-36.8728163,-36.8496888,-36.8494279,-36.8832081],\"longitude\":[174.7723731,174.7464657,174.7663288,174.7858216,174.7303048,174.7649894]},\"columns\":[{\"id\":\"name\",\"name\":\"name\",\"type\":\"character\"},{\"id\":\"storepoint_address\",\"name\":\"storepoint_address\",\"type\":\"character\"},{\"id\":\"latitude\",\"name\":\"latitude\",\"type\":\"numeric\"},{\"id\":\"longitude\",\"name\":\"longitude\",\"type\":\"numeric\"}],\"dataKey\":\"c696adcc55735c3f21083957d5b8f0fd\"},\"children\":[]},\"class\":\"reactR_markup\"},\"evals\":[],\"jsHooks\":[]}</script>\n```\n\n:::\n:::\n\n\n\n# Processing our Data\n\nFirst things first, we need to set up our spatial data. We're going to need 3 different pieces of data: \n\n## 1: The shape file for Auckland Central.\nThis is will be our map layer, showing where Auckland is.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(sf)\nlibrary(stringr)\n\nnz_sf <- read_sf(here(\"inputs\", \"shapefiles\", \"NZ_res01.shp\")) \n\n# Get the coordinates for Auckland in WGS84\nauckland_coords <- matrix(\n  c(\n    174.5, -37.0,  # min x, min y (SW corner)\n    174.95, -37.0,  # max x, min y (SE corner)\n    174.95, -36.7,  # max x, max y (NE corner)\n    174.5, -36.7,  # min x, max y (NW corner)\n    174.5, -37.0   # closing point (SW corner)\n  ), \n  ncol = 2,\n  byrow = TRUE\n)\n\n# Create a POLYGON from the bounding box and set CRS to WGS84\nauckland_polygon <- st_polygon(list(auckland_coords)) |> \n  st_sfc(crs = 4326) \n\n# Load the shapefile and transform to NZTM2000 (EPSG: 2193)\nauckland_sf <- nz_sf |> \n  # Intersect the Auckland shapefile with the Auckland bounding box\n  st_intersection(auckland_polygon) |>\n  st_transform(crs = 2193) \n```\n:::\n\n\n\n## 2: We'll need the road network data. \nWe'll need to filter this data to only include roads within Auckland, and we'll also need to make sure the [Coordinate Reference System (CRS)](https://datacarpentry.org/organization-geospatial/03-crs.html) is the same as our Auckland data. The CRS tells R which map projection to use, and if the layers in our data use different projections, the map won't look correct. You can use the function `st_crs(data)` to get the CRS of an object, and the `st_transform` to set it as the same.\n\nAs you can see, the road network data contains a range of variables identifying what type of road it is, and where it is located. We're going to filter out any roads that are not for cars.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#Load our road data\nnz_roads <- st_read(\n  here(\"inputs\",\"shapefiles\",\"NZ_roads.shp\"),\n  quiet = T\n  ) \n\n#set NZ roads CRS to be the same as the auckland sf.\n#nz_roads<-st_transform(nz_roads, st_crs(auckland_polygon)) \n#roads_inside_auckland <- st_intersection(nz_roads, auckland_polygon)\n\n#get the roads tidy\nauckland_roads <- nz_roads |>\n  filter(notforcar == 0) |>\n  filter(region == \"auckland\") |>\n  filter(!str_detect(label,\"auckland waiheke island ferry\"))  |>\n  st_transform(crs = 2193) \n\nhead(auckland_roads) |>\n  reactable()\n```\n\n::: {.cell-output-display}\n\n```{=html}\n<div class=\"reactable html-widget html-fill-item\" id=\"htmlwidget-cdae9cbf56ee0d2a36fc\" style=\"width:auto;height:auto;\"></div>\n<script type=\"application/json\" data-for=\"htmlwidget-cdae9cbf56ee0d2a36fc\">{\"x\":{\"tag\":{\"name\":\"Reactable\",\"attribs\":{\"data\":{\"OBJECTID\":[266441,266442,266451,266452,266453,266454],\"TARGET_FID\":[286952,286953,286962,286963,286964,286965],\"FID_nzogps\":[106464,102671,106461,106461,106461,106461],\"type\":[6,6,6,6,6,6],\"label\":[\"whiriwhiri rd\",\"hickey rd\",\"whiriwhiri rd\",\"whiriwhiri rd\",\"whiriwhiri rd\",\"whiriwhiri rd\"],\"descr\":[null,null,null,null,null,null],\"label3\":[null,null,null,null,null,null],\"city\":[\"waiuku\",\"waiuku\",\"waiuku\",\"waiuku\",\"waiuku\",\"waiuku\"],\"region\":[\"auckland\",\"auckland\",\"auckland\",\"auckland\",\"auckland\",\"auckland\"],\"country\":[\"new zealand~[0x1d]nz\",\"new zealand~[0x1d]nz\",\"new zealand~[0x1d]nz\",\"new zealand~[0x1d]nz\",\"new zealand~[0x1d]nz\",\"new zealand~[0x1d]nz\"],\"oneway\":[0,0,0,0,0,0],\"toll\":[0,0,0,0,0,0],\"speed\":[2,2,2,2,2,2],\"roadclass\":[0,0,0,0,0,0],\"roadid\":[768,789,768,768,768,768],\"level\":[0,0,0,0,0,0],\"endlevel\":[0,0,0,0,0,0],\"notforemer\":[0,0,0,0,0,0],\"notfordeli\":[0,0,0,0,0,0],\"notforcar\":[0,0,0,0,0,0],\"notforbus\":[0,0,0,0,0,0],\"notfortaxi\":[0,0,0,0,0,0],\"notforpede\":[0,0,0,0,0,0],\"notforbicy\":[0,0,0,0,0,0],\"notfortruc\":[0,0,0,0,0,0],\"road_class\":[\"Residential\",\"Residential\",\"Residential\",\"Residential\",\"Residential\",\"Residential\"],\"oneway_cha\":[null,null,null,null,null,null],\"Urban_Rura\":[0,0,0,0,0,0],\"sinuosity\":[1.00778818173531,1.01961796214714,1.05276050113657,1.06498903991691,1.02801127409111,1.0256999476808],\"road_name\":[\"WHIRIWHIRI RD\",\"HICKEY RD\",\"WHIRIWHIRI RD\",\"WHIRIWHIRI RD\",\"WHIRIWHIRI RD\",\"WHIRIWHIRI RD\"],\"highway\":[0,0,0,0,0,0],\"surface\":[1,1,1,1,1,1],\"arterial\":[0,0,0,0,0,0],\"estimated_\":[70,70,70,70,70,70],\"estimate_1\":[0.18130840456224,0.255498383067097,0.432409521922622,0.432409527925638,0.432409537401089,0.432409482947996],\"class_type\":[\"Non Urban Straight\",\"Non Urban Straight\",\"Non Urban Straight\",\"Non Urban Straight\",\"Non Urban Straight\",\"Non Urban Straight\"],\"Shape_Leng\":[211.52647198928,298.081446911613,504.477775576392,504.477782579911,504.477793634604,504.477730105995],\"geometry\":[{\"type\":\"LineString\",\"coordinates\":[[1751575.3999,5872128.3301],[1751702.8339,5872211.4856],[1751741.7787,5872256.2858]]},{\"type\":\"LineString\",\"coordinates\":[[1751741.7787,5872256.2858],[1751797.5734,5872203.1111],[1751859.9993,5872075.4536],[1751881.6819,5871999.5887]]},{\"type\":\"LineString\",\"coordinates\":[[1749735.0241,5870825.1247],[1749691.5967,5870875.8449],[1749690.9055,5871035.6788],[1749689.985,5871083.4197],[1749665.1761,5871183.7513],[1749666.5832,5871262.527],[1749693.1403,5871302.486]]},{\"type\":\"LineString\",\"coordinates\":[[1750034.263,5871656.8015],[1750035.4598,5871658.8141],[1750043.823,5871729.6962],[1750134.7693,5871806.8684],[1750146.9855,5871944.2737],[1750135.1387,5872025.5067],[1750160.6897,5872113.3114]]},{\"type\":\"LineString\",\"coordinates\":[[1750601.8123,5872255.6716],[1750812.937,5872287.4775],[1751013.9905,5872223.9244],[1751088.8175,5872195.3094]]},{\"type\":\"LineString\",\"coordinates\":[[1749693.1403,5871302.486],[1749743.1256,5871377.6959],[1749814.1468,5871431.9201],[1749891.0963,5871470.4994],[1749953.1554,5871519.3334],[1749960.4258,5871529.1921],[1749966.8891,5871543.5048],[1750034.263,5871656.8015]]}]},\"columns\":[{\"id\":\"OBJECTID\",\"name\":\"OBJECTID\",\"type\":\"numeric\"},{\"id\":\"TARGET_FID\",\"name\":\"TARGET_FID\",\"type\":\"numeric\"},{\"id\":\"FID_nzogps\",\"name\":\"FID_nzogps\",\"type\":\"numeric\"},{\"id\":\"type\",\"name\":\"type\",\"type\":\"numeric\"},{\"id\":\"label\",\"name\":\"label\",\"type\":\"character\"},{\"id\":\"descr\",\"name\":\"descr\",\"type\":\"character\"},{\"id\":\"label3\",\"name\":\"label3\",\"type\":\"character\"},{\"id\":\"city\",\"name\":\"city\",\"type\":\"character\"},{\"id\":\"region\",\"name\":\"region\",\"type\":\"character\"},{\"id\":\"country\",\"name\":\"country\",\"type\":\"character\"},{\"id\":\"oneway\",\"name\":\"oneway\",\"type\":\"numeric\"},{\"id\":\"toll\",\"name\":\"toll\",\"type\":\"numeric\"},{\"id\":\"speed\",\"name\":\"speed\",\"type\":\"numeric\"},{\"id\":\"roadclass\",\"name\":\"roadclass\",\"type\":\"numeric\"},{\"id\":\"roadid\",\"name\":\"roadid\",\"type\":\"numeric\"},{\"id\":\"level\",\"name\":\"level\",\"type\":\"numeric\"},{\"id\":\"endlevel\",\"name\":\"endlevel\",\"type\":\"numeric\"},{\"id\":\"notforemer\",\"name\":\"notforemer\",\"type\":\"numeric\"},{\"id\":\"notfordeli\",\"name\":\"notfordeli\",\"type\":\"numeric\"},{\"id\":\"notforcar\",\"name\":\"notforcar\",\"type\":\"numeric\"},{\"id\":\"notforbus\",\"name\":\"notforbus\",\"type\":\"numeric\"},{\"id\":\"notfortaxi\",\"name\":\"notfortaxi\",\"type\":\"numeric\"},{\"id\":\"notforpede\",\"name\":\"notforpede\",\"type\":\"numeric\"},{\"id\":\"notforbicy\",\"name\":\"notforbicy\",\"type\":\"numeric\"},{\"id\":\"notfortruc\",\"name\":\"notfortruc\",\"type\":\"numeric\"},{\"id\":\"road_class\",\"name\":\"road_class\",\"type\":\"character\"},{\"id\":\"oneway_cha\",\"name\":\"oneway_cha\",\"type\":\"character\"},{\"id\":\"Urban_Rura\",\"name\":\"Urban_Rura\",\"type\":\"numeric\"},{\"id\":\"sinuosity\",\"name\":\"sinuosity\",\"type\":\"numeric\"},{\"id\":\"road_name\",\"name\":\"road_name\",\"type\":\"character\"},{\"id\":\"highway\",\"name\":\"highway\",\"type\":\"numeric\"},{\"id\":\"surface\",\"name\":\"surface\",\"type\":\"numeric\"},{\"id\":\"arterial\",\"name\":\"arterial\",\"type\":\"numeric\"},{\"id\":\"estimated_\",\"name\":\"estimated_\",\"type\":\"numeric\"},{\"id\":\"estimate_1\",\"name\":\"estimate_1\",\"type\":\"numeric\"},{\"id\":\"class_type\",\"name\":\"class_type\",\"type\":\"character\"},{\"id\":\"Shape_Leng\",\"name\":\"Shape_Leng\",\"type\":\"numeric\"},{\"id\":\"geometry\",\"name\":\"geometry\",\"type\":[\"sfc_LINESTRING\",\"sfc\"]}],\"dataKey\":\"75122ddc38e00ac16f6e4832b2c99080\"},\"children\":[]},\"class\":\"reactR_markup\"},\"evals\":[],\"jsHooks\":[]}</script>\n```\n\n:::\n:::\n\n\n\n\n## 3: We need to transform our tennis club location data\nWe'll need to make sure it's in the same format and CRS.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#clean point df and put to sf\npoint_sf <- df_clean |>\n  st_as_sf(\n    coords = c(\"longitude\", \"latitude\"),\n    crs = 4326\n  ) \n\npoint_sf_auckland <- point_sf |>\n  st_intersection(auckland_polygon) |>\n  st_transform(crs = 2193) \n```\n:::\n\n\n\n# Calculating Isodistances\n\nBy getting the point data and the road map data into the same format, we've done much of the hard work. Our next step involves generating isodistance polygons from each of the tennis clubs based on the road network. We'll make use of the `calc_isochrones` function from the [`spNetwork`](https://rdrr.io/github/JeremyGelb/spNetwork/) package to accomplish this. The results of this function are passed onto the [`concaveman`](https://cran.r-project.org/web/packages/concaveman/index.html) package which provides polygons for our mapping use. The code below goes through each point in our tennis club data, and generates an isodistance around them of 5km.\n\nNote: This function can take a bit of time to run, depending on the processing power available. You can set multiple distance values, which is really handy, but for now we will stick to 5000m (5km). \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(spNetwork)\nlibrary(concaveman)\nfor(i in 1:nrow(point_sf_auckland)){\n  \n  cat(\"\\nGenerating isodistance for \",i,\":\", point_sf_auckland$storepoint_address[i])\n  \n  iso_results <- calc_isochrones(\n    lines = auckland_roads,\n    start_points = point_sf_auckland[i,],\n    dists = c(5000),\n    weight = \"Shape_Leng\"\n  )\n  # identifying each isocdistance\n  iso_results$iso_oid <- paste(\n    iso_results$point_id,\n    iso_results$distance,\n    sep = \"_\"\n  )\n  \n  # creating the polygons for each isodistance\n  polygons <- lapply(unique(iso_results$iso_oid), function(oid){\n    \n    # subseting the required lines\n    lines <- subset(iso_results, iso_results$iso_oid == oid)\n    \n    # extracting the coordinates of the lines\n    coords <- st_coordinates(lines)\n    poly_coords <- concaveman(points = coords, concavity = 3)\n    poly <- st_polygon(list(poly_coords[,1:2]))\n    return(poly)\n  })\n  \n  # creating a SpatialPolygonsDataFrame\n  iso_sp <- st_sf(\n    iso_oid = unique(iso_results$iso_oid),\n    distance = unique(iso_results$distance),\n    geometry = polygons,\n    crs = st_crs(iso_results)\n  ) %>%\n    mutate(storepoint_address = point_sf_auckland$storepoint_address[i])\n  \n  iso_sp %>%\n    write_sf(here(\"inputs\",\"tennis\",paste0(\"tennis_polygon_\",i,\".shp\")))\n}\n```\n:::\n\n\n\nThe above code chunk will save each tennis club isodistance as an individual shape file. We can load them individually, or grab them all and put them in a dataset as shown below.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndrive_isochrone_list<-list()\nFILES <- list.files(here(\"inputs\",\"tennis\"),full.names = T)\nSHP_FILES <- FILES[str_detect(FILES,\".shp$\")]\nfor(i in 1:length(SHP_FILES)){\n  file_sf<-read_sf(SHP_FILES[i])\n  drive_isochrone_list[[i]] <- file_sf\n}\ndrive_isochrone_sf <- sf::st_as_sf(data.table::rbindlist(drive_isochrone_list))\n```\n:::\n\n\n\n# Visualisation\n\nAnd here's what our distances look like. Maps like these can be very valuable for identifying gaps in access. Are there any places that tennis clubs isodistances do not cover?\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggplot2)\n\n# Plotting\nggplot() +\n  geom_sf(\n    data = auckland_sf,\n    alpha = 1,\n    fill=\"black\",\n    colour=\"black\",\n    linewidth=0.2\n  ) +\n  geom_sf(\n    data = auckland_roads,\n    alpha = 1,\n    colour=\"grey80\",\n    linewidth=0.1\n  ) +\n  geom_sf(\n    data = drive_isochrone_sf, \n    aes(fill = 'Driving Distance (5km)'),\n    alpha = 0.25,\n    colour=\"white\"\n  ) +\n  geom_sf(\n    data = point_sf_auckland |>\n      filter(storepoint_address %in% unique(drive_isochrone_sf$strpnt_)),\n    color = 'black',\n    fill=\"#ccff00\",\n    shape=21,\n    size=5,\n    alpha=0.9\n  ) +\n  theme_void() +\n  theme(\n    legend.title = element_blank(),\n    legend.spacing = unit(0,\"lines\"),\n    legend.position = \"bottom\",\n    legend.text = element_text(size=20),\n    title = element_text(size=20)\n  ) +\n   coord_sf(crs = 4326,\n    xlim = c(174.6, 174.95),\n    ylim = c(-37, -36.72)\n  ) +\n  ggtitle(\"5km Driving Isodistances of\\nAuckland Tennis Clubs\")\n```\n\n::: {.cell-output-display}\n![](SecondSet_Drive_Isodistances_files/figure-html/plot-1.png){width=960}\n:::\n:::\n\n\n\nIt's important to bear in mind the quality of the data is always important when drawing conclusions. For example, we know some tennis clubs are missing from our data, so some gaps in access may not really be gaps. This method also relies on having road network data available for use. [A lot of work](https://www.canterbury.ac.nz/content/dam/uoc-main-site/documents/pdfs/reports/geohealth-laboratory/Creating-a-Road-Network-Analysis-Layer-with-Travel-Time-Estimates-using-Opensource.pdf) can go into processing these data, while there are other open source options/libraries available as well, such [`openrouteservice`](https://openrouteservice.org/). \n\nThe key advantages of this approach is that it avoids using API calls, instead using a local shape file of the NZ road network. This means that we could iterate through a whole range of distances, and process a whole load of data (even if it may take some time). Key things to watch out for, as always, is data quality. External services with an API may be more reliable.\n\n",
    "supporting": [
      "SecondSet_Drive_Isodistances_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<script src=\"../../site_libs/core-js-2.5.3/shim.min.js\"></script>\n<script src=\"../../site_libs/react-18.2.0/react.min.js\"></script>\n<script src=\"../../site_libs/react-18.2.0/react-dom.min.js\"></script>\n<script src=\"../../site_libs/reactwidget-2.0.0/react-tools.umd.cjs\"></script>\n<link href=\"../../site_libs/htmltools-fill-0.5.8.1/fill.css\" rel=\"stylesheet\" />\n<script src=\"../../site_libs/htmlwidgets-1.6.4/htmlwidgets.js\"></script>\n<link href=\"../../site_libs/reactable-0.4.4/reactable.css\" rel=\"stylesheet\" />\n<script src=\"../../site_libs/reactable-binding-0.4.4/reactable.js\"></script>\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}